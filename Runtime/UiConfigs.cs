using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

// ReSharper disable CheckNamespace

namespace Geuneda.UiService
{
	/// <summary>
	/// Represents a configuration of an <seealso cref="UiPresenter"/> with all it's important data
	/// The Id is the int representation of the UI generated by the UiIdsGenerator code generator
	/// </summary>
	[Serializable]
	public struct UiConfig
	{
		[FormerlySerializedAs("AddressableAddress")]
		public string Address;
		public int Layer;
		public Type UiType;
		public bool LoadSynchronously;
	}

	/// <summary>
	/// ScriptableObject tool to import the <seealso cref="UiConfig"/> & <seealso cref="UiSetConfig"/> to be used in the <see cref="IUiService"/>.
	/// Use one of the derived types to create a UiConfigs asset:
	/// <list type="bullet">
	/// <item><see cref="AddressablesUiConfigs"/> - for Addressables-based loading</item>
	/// <item><see cref="ResourcesUiConfigs"/> - for Resources folder loading</item>
	/// <item><see cref="PrefabRegistryUiConfigs"/> - for direct prefab references</item>
	/// </list>
	/// </summary>
	public abstract class UiConfigs : ScriptableObject//, IConfigsContainer<UiConfig>
	{
		[SerializeField]
		private List<UiConfigSerializable> _configs = new List<UiConfigSerializable>();
		[SerializeField]
		private List<UiSetConfigSerializable> _sets = new List<UiSetConfigSerializable>();

		/// <summary>
		/// Gets or sets the list of UI configurations
		/// </summary>
		public List<UiConfig> Configs
		{
			get { return _configs.ConvertAll(element => (UiConfig)element); }
			set { _configs = value.ConvertAll(element => (UiConfigSerializable)element); }
		}

		/// <summary>
		/// Gets the list of UI set configurations
		/// </summary>
		public List<UiSetConfig> Sets => _sets.ConvertAll(element => UiSetConfigSerializable.ToUiSetConfig(element));

		/// <summary>
		/// Sets the new size of this scriptable object <seealso cref="UiSetConfig"/> list.
		/// The UiConfigSets have the same id value that the index in the list.
		/// Validates entries against available UI configs.
		/// </summary>
		/// <param name="size">The new size of the list</param>
		public void SetSetsSize(int size)
		{
			var validTypeNames = new HashSet<string>(_configs.Select(c => c.UiType));
			
			if (size < _sets.Count)
			{
				_sets.RemoveRange(size, _sets.Count - size);
			}

			for (int i = 0; i < size; i++)
			{
				if (i < _sets.Count)
				{
					var set = _sets[i];
					
					// Initialize UiEntries if null
					if (set.UiEntries == null)
					{
						set.UiEntries = new List<UiSetEntry>();
					}
					
					// Remove entries that reference non-existent UI types
					set.UiEntries.RemoveAll(entry => !validTypeNames.Contains(entry.UiTypeName));
					_sets[i] = set;
					continue;
				}

				_sets.Add(new UiSetConfigSerializable { SetId = i, UiEntries = new List<UiSetEntry>() });
			}
		}

		/// <summary>
		/// Necessary to serialize the data in scriptable object
		/// </summary>
		[Serializable]
		public struct UiConfigSerializable
		{
			[FormerlySerializedAs("AddressableAddress")]
			public string Address;
			public int Layer;
			public string UiType;

			public static implicit operator UiConfig(UiConfigSerializable serializable)
			{
				return new UiConfig
				{
					Address = serializable.Address,
					Layer = serializable.Layer,
					UiType = Type.GetType(serializable.UiType),
					LoadSynchronously = false
				};
			}

			public static implicit operator UiConfigSerializable(UiConfig config)
			{
				return new UiConfigSerializable
				{
					Address = config.Address,
					Layer = config.Layer,
					UiType = config.UiType.AssemblyQualifiedName
				};
			}
		}

	}
}